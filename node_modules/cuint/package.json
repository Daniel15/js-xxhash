{
  "name": "cuint",
  "version": "0.0.0",
  "description": "Unsigned integers for Javascript",
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/pierrec/js-cuint"
  },
  "keywords": [
    "C",
    "unsigned",
    "integer",
    "32bits",
    "64bits"
  ],
  "author": {
    "name": "Pierre Curto"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/pierrec/js-cuint/issues"
  },
  "homepage": "https://github.com/pierrec/js-cuint",
  "readme": "# C-like unsigned integers for Javascript\n\n## Synopsis\n\nJavascript does not natively support handling of unsigned 32 or 64 bits integers. This library provides that functionality, following C behaviour, enabling the writing of algorithms that depend on it.\n\nTODO\n64 bits integers not supported yet!\n\n\n## How it works\n\nAn unsigned 32 bits integer is represented by an object with its first 16 bits (low bits) and its 16 last ones (high bits). All the supported standard operations on the unsigned integer are then performed transparently.\n\n\te.g.\n\t10000010000100000100010000100010 (2182104098 or 0x82104422) is represented by:\n\thigh=1000001000010000\n\tlow= 0100010000100010\n\nNB.\nIn case of overflow, the unsigned integer is _truncated_ to its lowest 32 bits.\n\nThe same applies to 64 bits integers, which are split into 4 16 bits ones.\n\n## Installation\n\nIn nodejs:\n\n    npm install cuint\n\nIn the browser, include the following, and access the constructor with _UINT32_:\n\n`<script src=\"/your/path/to/uint32.js\"></script>\n...\n<script type=\"text/javascript\">\n  var prime1 = UINT32('3266489917');\n  var prime2 = UINT32('2654435761');\n  var prime1plus2 = prime1.add(prime2)\n</script>`\n\n## Usage\n\nTo instantiate an unsigned 32 bits integer, do any of the following:\n\n\tvar UINT32 = require('cuint').UINT32 // NodeJS\n\tUINT32( <low bits>, <high bits> )\n\tUINT32( <number> )\n\tUINT32( '<number>' )\n\n## Examples\n\n* Using low and high bits\n> `UINT32( 2, 1 )\t\t// 65538`\n> { remainder: null, _low: 2, _high: 1 }\n\n* Using a number (signed 32 bits integer)\n> `UINT32( 65538 ) \t// 65538`\n> { remainder: null, _low: 2, _high: 1 }\n\n* Using a string\n> `UINT32( '65538' )\t// 65538`\n> { remainder: null, _low: 2, _high: 1 }\n\n* Using another string\n> `UINT32( '3266489917' )`\n> { remainder: null, _low: 44605, _high: 49842 }\n\n* Divide 2 unsigned 32 bits integers - note that the remainder is also provided\n> `UINT32( '3266489917' ).div( UINT32( '668265263' ) )`\n> {\tremainder:\n>\t\t\t{\tremainder: null\n>\t\t\t,\t_low: 385\n>\t\t\t,\t_high: 9055\n>\t\t\t}\n>\t,\t_low: 4\n>\t,\t_high: 0\n>\t}\n\n## Methods\n\n* `UINT32.fromBits(<low bits>, <high bits>)*`\nSet the current _UINT32_ object with its low and high bits\n* `UINT32.fromNumber(<number>)*`\nSet the current _UINT32_ object from a number\n* `UINT32.fromString(<string>, <radix>)*`\nSet the current _UINT32_ object from a string\n* `UINT32.toNumber()`\nConvert this _UINT32_ to a number\n* `UINT32.toString(<radix>)`\nConvert this _UINT32_ to a string\n* `UINT32.add(<uint>)*`\nAdd two _UINT32_. The current _UINT32_ stores the result\n* `UINT32.subtract(<uint>)*`\nSubtract two _UINT32_. The current _UINT32_ stores the result\n* `UINT32.multiply(<uint>)*`\nMultiply two _UINT32_. The current _UINT32_ stores the result\n* `UINT32.div(<uint>)*`\nDivide two _UINT32_. The current _UINT32_ stores the result.\nThe remainder is made available as the _remainder_ property on the _UINT32_ object.\nIt can be null, meaning there are no remainder.\n* `UINT32.negate()` alias `UINT32.not()`\nNegate the current _UINT32_\n* `UINT32.equals(<uint>)` alias `UINT32.eq(<uint>)`\nEquals\n* `UINT32.lessThan(<uint>)` alias `UINT32.lt(<uint>)`\nLess than (strict)\n* `UINT32.greaterThan(<uint>)` alias `UINT32.gt(<uint>)`\nGreater than (strict)\n* `UINT32.or(<uint>)*`\nBitwise OR\n* `UINT32.and(<uint>)*`\nBitwise AND\n* `UINT32.xor(<uint>)*`\nBitwise XOR\n* `UINT32.shiftRight(<number>)*` alias `UINT32.shiftr(<number>)*`\nBitwise shift right\n* `UINT32.shiftLeft(<number>[, <allowOverflow>])*` alias `UINT32.shiftl(<number>[, <allowOverflow>])*`\nBitwise shift left\n* `UINT32.rotateLeft(<number>)*` alias `UINT32.rotl(<number>)*`\nBitwise rotate left\n* `UINT32.rotateRight(<number>)*` alias `UINT32.rotr(<number>)*`\nBitwise rotate right\n* `UINT32.clone()`\nClone the current _UINT32_\n\nNB. methods with an * do __modify__ the object it is applied to. Input objects are not modified.\n\n## License\n\nMIT\n\n\n> Written with [StackEdit](https://stackedit.io/).",
  "readmeFilename": "README.md",
  "_id": "cuint@0.0.0",
  "_from": "cuint@latest"
}
